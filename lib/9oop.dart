//подключение к программе модулей с другими классами
import 'logic/cat_import.dart';

// 1. Инкапсуляция (вложенность, знаем результат (видим интерфейс) а в нюансах (приватные методы и конструкторы) нет), принцип чёрного ящика.
// Cокрытие внутренних данных компонента и деталей его реализации от других компонентов приложения и предоставление набора методов для взаимодействия с ним (API)

// 2. Наследование (транспортное средство - наземное тр. средство - автомобиль)
// 3. Полиморфизм (схожие действия но по различной логике). Например, общее для всех автомобилей действие «завестись» у спортивного автомобиля может быть реализовано путем нажатия кнопки, а у грузового - с помощью ключа. Один результат – разные решения. В этом и состоит полиморфизм.
// 4. Абстракция - ассемблер является в своём роде абстракцией соответствующих микропроцессоров, поскольку позволяет отвлечься от деталей их реализации и общаться с ними через определённый набор более высокоуровневых инструкций.

/* S.O.L.I.D.
S – Single Responsibility (Принцип единственной ответственности)
Каждый класс должен отвечать только за одну операцию.

O — Open-Closed (Принцип открытости-закрытости)
Классы должны быть открыты для расширения, но закрыты для модификации.

L — Liskov Substitution (Принцип подстановки Барбары Лисков)
Если П является подтипом Т, то любые объекты типа Т, присутствующие в программе,
могут заменяться объектами типа П без негативных последствий для функциональности программы.

I — Interface Segregation (Принцип разделения интерфейсов)
Не следует ставить клиент в зависимость от методов, которые он не использует.
Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента.
Клиенты не должны зависеть от интерфейсов, которые они не используют.

D — Dependency Inversion (Принцип инверсии зависимостей)
Объектом зависимости должна быть абстракция, а не что-то конкретное.
Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
 */

//наименование не может начинаться с цифры
class Cat {
  // создание полей
  String name = '';
  int age = 0;
  String color = '';
}

void oop() {
  //создание объекта класса
  //имя_класса имя = имя_класса()
  Cat cat = Cat();
  print('объект класса cat: name = ${cat.name}, age= ${cat.age}, color= ${cat.color}  ');

  cat.name = 'Кузя';
  cat.age = 5;
  cat.color = 'Чёрный';
  print('объект класса cat: name = ${cat.name}, age= ${cat.age}, color= ${cat.color}  ');

  //каскадное обращение к объектам класса
  Cat cat2 =Cat()
  .. name = 'Вася'
  .. age = 1
  .. color = 'серый';

  cat2..name = 'Василий' ..age=3;

  print('объект класса cat2: name = ${cat2.name}, age= ${cat2.age}, color= ${cat2.color}  ');

  CatC catC1 = CatC('Барсик', 3, 'пятнистый');
  print('объект класса catC: name = ${catC1.name}, age= ${catC1.age}, color= ${catC1.color}  ');

  CatC catC2 = CatC.noParams();
  print('объект класса catC: name = ${catC2.name}, age= ${catC2.age}, color= ${catC2.color}  ');

}

//конструктор - метод с именем класса и не указанным возвращаемым типом данных
class CatC {
  // создание полей
  String name = '';
  int age = 0;
  String color = '';

  //конструктор
  CatC(String name, int age, String color){
 this.name=name;
 this.age=age;
 this.color=color;
  }

  //именованные конструкторы
  CatC.noParams();
  CatC.named(String name){
    this.name=name;
  }
  CatC.aged(this.age);
  CatC.namedAged(String name, int age): this (name, age, 'Белый');

}

class CatT {
  // создание полей
  String name;
  int age;
  String color;

  //конструктор (сокращённый)
  //CatT({required this.name, required this.age, required this.color});

  //инициализаторы
  CatT (name, age, color): this.name = 'кот ' + name, this.age=age, this.color=color {
  if (this.age<0) {this.age=1;}
  }

}

class CatConst {
  // создание полей
  final String name;
  final int age;
  final String color;

  //константный конструктор, нужен чтобы инициализированные переменные не менялись
  const CatConst(this.name, this.age, this.color);

}

//есть ещё цепочки конструкторов
//В данном случае первый и второй конструктор вызывают третий, в котором собственно будут устанавливаться поля name и age.
class Person{
  String name = "";
  int age = 0;

  //1ый конструктор (вызывает 3-ий)
  Person.undefined(): this("undefined", 18);
  //2ой конструктор (вызывает 3-ий)
  Person.fromName(String name): this(name, 18);
  //3ий конструктор
  Person(this.name, this.age);

  void display(){
    print("Name: $name Age: $age");
  }
}